# key 设计
* 格式固定。比如[功能名]:[数据名]:[数据]
* key的长度尽量小，6.x 小于44字节 低版本更小

# bigKey
* 衡量标准
  * 单个key的value不要过大。最好小于10kb
  * 单个集合类型key，元素不要超过1000
  * 集合类型key总字节量不要太大
* 危害
  * 网络阻塞
  * 分片集群场景下导致内存分布不均匀
  * 大key的操作更耗时，redis是单线程的
  * redis的操作基于resp协议，协议必然存在序列化和反序列化，耗费大量CPU

# 批处理
* 原理： 一次性发送有多条命令的数据包
* 原因： 网络耗时（毫秒级）远大于redis的内存操作（10微妙）
* 方法：
  * 批量操作命令
    * mset 、 hmset 等
    * 但是只能针对string 和 hash类型。
  * 管道
    * 管道模式和批处理不一样。批处理是一个事务，而管道是一次性发送多个事务。一条SQL一个事务
    * 管道是多条命令的集合，所以没有类型和key的限制
* 缺陷：
  * 管道一次性发送的太多必然引起网络的拥挤
  * 同时因为一次需要接收的命令多了，redis服务端的网络缓冲区也会变大
  * 分片集群模式下，一次批处理的所有key必须落在同一个分槽中，否则将无法批量操作
  
# 部署模式的优化
* 优先选择单机部署
* 单个redis实例的内存不宜过高
* 按业务分实例优于集群部署
* 采用主从模式时必须考虑主备数据不一致性问题

# 慢查询优化
* 配置
  * slowlog-log-slower-than : 慢查询阈值。
    * 单位：微妙
  * slowlog-max-len : 慢查询命令队列大小。超出自动删除
    * 默认128，可适当加大
* 命令
  * slowlog get : 获取慢查询日志
  * slowlog reset: 清空缓冲区

# 内存优化
* 内存查询命令
  * info memory
  * memory XXX
* 缓冲区内存大小配置
  * repl-backlog-buf : repl-backlog-size 
  * AOF缓冲区 : 
  * 网络IO缓冲区
    * 输入缓冲区：固定值。慢查询就导致命令阻塞，从而导致输入缓冲区堆满
    * 输出缓冲区：client-output-buffer-limit
* 元素优化
  * redisObject 优先long，其次字符串小于44kb，set、sortset、hash 元素数量少一点，list 无所谓
