#IO 
##序言
原本我只是想研究Netty框架，但是在接触Netty之后，我发现，Netty通常和NIO直接关联。那我就在思考：  
- IO是什么？  
- 为什么IO会这么复杂，分为了BIO，NIO，AIO， 它到底复杂在哪儿呢？
- BIO到底阻塞在哪里？ NIO又是怎样解决Block问题的呢？  
- JDK已经存在了NIO，Netty是个啥玩意？Netty存在的意义是什么？业界有句经典的话：使用netty后，IO不存在性能问题。可信吗？ 

**声明** 本系列专注网络IO，所以主讲都是以网络IO的实现为例子 

###解释
**IO**  
  input & output的缩写  
  举个例子： 两个人面对面，A在说话，B在听。  
          那么可以看作：A就在输出内容（output），B在输入内容(input)，输入/输出的内容就是文字，媒介是空气，传递的具体实现是音波。 
  
  类比网络IO： 客户端给服务端发送消息，客户端在输出，服务端在输入，内容是消息，媒介是网线，传递的具体实现是电信号(0/1)  
同时我们传递的内容（消息或者对话）都不可能是一字或者一个信号，而是一长段文字或者信号，就像流水一样，所以，我们把它叫做：输入流/输出流（inputSteam/outputStream）

*那么问题就来了：怎么实现IO呢？*

###网络IO的实现  
[网络模型](./image/networkModel.png)   

####网络物理层  
就像两个人对话，空气是天然存在的，音波这种物理现象我们也不去深入研究  
所以我们的基础条件网络接口层已经存在，且传输的内容是二进制字节码  
####数据链路层   
*帧*  
我们实际中进行传输的时候肯定是一段字节流，不可能一个字节一个字节的传输，所以在物理层之上，网络传输规范定义了一个网络链路层，用于把数据
包装成一段一段的字节流，而这个段被定义为帧。  
所以：帧是网络接口层传输的最小单位。  
我们玩游戏的时候，常说【掉帧】，实际上就是传输的片段丢失。这无关上层应用本身，就是网络太差，数据传输失败  
总结：数据链路层就是为了完成数据切片传输的功能，为网络物理层做准备，而实现这一功能的硬件在我们电脑上叫做：网卡  

####网络层  
上面两层已经实现了两个点对点的通信。那么问题来了： *互联网是一个网状结构，我怎么知道我要找谁呢？*  
所以网络层的意义：**点位**  
IP协议就是广泛使用的网络层现已，改协议为每台连接到互联网的机器分配一个IP，这样每台机器就有了自己的唯一标记，不管你在何方，只要你注册了，我就能找到你。
怎么做的呢？
关键装备： 路由器！ 
 
                    顶级路由器  
                  /         \
            美国顶级路由器     中国总路由器  
              ...         /     ｜     \
                       移动      电信     联通      
                       ...       |       ...
                              省级路由器
                            /    |     \
                          宁波   杭州   ...
                               /    \ 
                         兑吧路由器  阿里云
                           /   \  
                          5楼  7楼     
                         /  \
                    我的电脑 你的电脑

想象一下，现在有一个路由器B1，它上面插了3根网线，挂载了3台电脑（A1,A2,A3）,路由器B1它又连接在公司的总路由器C1上，这个C1上其实挂载的不只你的路由器B1，还有B2,B3....
公司路由器C1的上面连接的可能是某个省级电信的路由器D1，D1上实际挂载着C1,C2,C3....这个D1之上可能就是中国的总路由器E1，E1下挂载着电信（D1）,移动（D2），联通（3）....
至于怎么联通世界互联网的，可以翻阅资料，在94年，中国第一个网站：【世界之窗】，正式宣布中国互联网时代的到来。  
那么问题来了：  
- 1、互联网那么多机器，IP要怎么分配呢？路由器如何判断是向上还是向下呢？ [ip协议](./ip/readme.md)  
- 2、这里说的都是通过网线进行传输的场景。那Wi-Fi怎么定位呢？  

####传输层  
首先根据以上已经学习的内容，考虑两个问题：
- 1、A给B发消息，如果我的消息特别特别长，比如1个G的大文件，B怎么知道A有没有发完呢？    
- A给B发了个消息，A怎么知道B有没有收到呢？  
为了解决这些问题，在网络层之上，就出现了传输层。这一层的任务就是完成以上两个问题。  
比如：我们特别熟悉的TCP协议，和UDP协议。TCP协议就尽全力保证消息的可靠性，而UDP则不完全保证  
那么问题来了：TCP怎么保证的呢？大家都知道3次握手，4次挥手，为什么这么设计呢？  
[TCP](./tcp/readme.md)

如果大家专注于IO编程，那到这里的知识点，都是基础。为什么呢？  
- 其实在JDK中，跟网络IO最直接相关联的就是Socket对象。那socket内部对网络IO的实现，就到这里了。再往上的那些个协议，就需要其他扩展框架或者自定义了。  
- 下层的协议就那么几个，但是从此往上，那就五花八门了。比如：http,Ftp，ssl，websocket，smtp等等。  

为什么我们通常把整个网络层级统称为TCP-IP协议群呢？其实就是因为后续的所有实现，都是基于TCP/IP协议的。 
到此处的协议基本都是硬件和操作系统帮助我们实现的。所以我们从Java代码的角度去学习IO的话，也是从此开始的。而这个在JDK中相应的实现就是socket API  
[socket](./socket/readme.md)

####应用层  
后面的三层分为：会话层，表现层，应用层。个人感觉，就是那群学者脑子有病。无关紧要。我这里统一理解为应用层  
我们可以传输数据了，但是国有国法，家有家规。消息可以可靠传输了，但是你不能乱传。  
想象一个场景：  
你有个服务器S，客户端A发给你一条消息：aaaa，客户端B发给你一条消息：bbbb。  
你是不是想问：啥意思，给我这个干嘛？我需要帮你做点啥吗？

   
大家最熟悉的HTTP请求，其实在JDK socket中接收到的，就是一段字符串，啥也不是，根本看不懂，什么也干不了。但是我们都在用tomcat服务器，tomcat最重要的功能是什么？提供服务器吗？
你自己new 一个 ServerSocket不行吗？那肯定不行。 tomcat最重要的部分就是它实现了servlet规范。通常场景下，tomcat把客户端发来的消息封装成了HttpServletRequest，
把服务器发给客户端的消息封装成了HttpServletResponse。对普通开发者来说，这样就简单了很多。这就是应用层协议。  

####总结
回头再来看一个图：  
[网络结构图](./image/networkExp.png)  

*网络层和传输层的协议都是由操作系统来实现了，而应用层协议由框架来实现的。那么问题来了，从操作系统到应用，是怎么连接的呢？*  


###HTTP协议
