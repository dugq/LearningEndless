# RPC
* RPC：remote Procedure call 指的是：A计算机上的一个进程调用B计算机上的一个进程，此时A计算机的进程挂起，B计算机的进程开始。等待B计算机上的进程结束并将结果返回给A计算机上的进程，并唤醒A计算机上的进程继续执行的过程。
* RPC 说起来简单，实现起来比较麻烦，需要一系列的组建一起工作
  * 服务的注册与发现。 现代服务大都采用微服务化的分布式集群模式部署，需要有一个东西来管理所有的节点。这些包括：eureka  zookeeper nacos 等。
  * 负载均衡。发现的服务端多的时候，就需要做负载均衡，保证整体服务的高性能。ribbon，dubbo集成的也有 等
  * 熔断处理。异常情况处理方案。高可用模型
  * 序列化（编解码）。一般的程序都是面向对象设计，而传输层接受的是字节数组，序列化完成的就是这样一个转换过程。
  * 传输协议。远程通信的必要部分。 有些采用应用层的http协议，有些则直接采用Tcp协议
  * IO模型。这牵涉到连接的复用等，以及同步、阻塞等情况，好的IO模型可以有效的提高RPC的性能
* RPC是“单体服务”走向“微服务”过程中的必要手段。

## RPC负责的事
* 序列话
* 多线程/并发 发起IO
* 锁处理资源竞争
* 流量控制
* 负载均衡
## 协议
* **dubbo**
  * dubbox
  * motan
* **grpc**
* **sofa-pbrpc**
* hessian
* http
  * 优势：
    * 协议很成熟，tomcat，jboss等服务提供端，httpclinet等客户端都很齐全
  * 劣势：
    * 协议复杂，冗余字段较多，传输文本较大
* rmi
* web service
* thrift
* memcached
* redis


## 序列化
* json
  * 和xml一样，有点在于简单且结构一目了然
  * 缺点在于序列化面向字符串，效率不高
* xml
* protocol buffers
  * 语言无关，平台无关。linux等多个平台都可支持，支持Java，C++等多种语言
  * 高效 序列化更快，序列化后的字节数更少
  * 安全性。数据经过编码后，抓包获取的字节流不好解析
  * 扩展性，兼容性好。类似json
  * 缺点1：使用起来不是很方便，而且序列话后的文本看不懂
  * 缺点2:扩展性比json差，只适合追加字段
* Kryo
  * 性能上 比json 好，比protostuff差
  * 扩展性不好，不能修改字段，跨语言能力差
* FST
  * 
