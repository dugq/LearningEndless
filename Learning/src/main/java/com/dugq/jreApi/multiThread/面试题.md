##### 线程和进程的区别

<details>
    <summary>
        解题思路
    </summary>
 从各自的存在的意义，实际占用资源的情况 和 特点（独立性、通信等）进行分析
 理论上，线程是进程的子集
</details>
<details>
    <summary>
        百度百科
    </summary><br>
  线程和进程在操作系统中都是为了实现并发执行的一种手段，但它们有以下关键的区别：

* 资源占用：线程是进程的子集，每个线程共享其所属进程的资源，包括代码、数据和系统资源。而进程是独立的，拥有自己的资源，如内存空间、文件描述符等。
* 执行方式：进程是独立执行的，有完整的地址空间和系统资源。线程作为进程的组成部分，多个线程共享进程的资源。
* 开销：进程的创建和销毁需要较大的开销，因为需要分配和回收资源。而线程的创建和销毁的开销相对较小，因为它们共享进程的资源。
* 并发性：由于线程共享进程资源，同一进程的多个线程之间可以直接读写共享内存，执行速度更快，因此并发性高。而进程间通信（IPC）需要通过专门的机制，如管道、消息队列、信号量等，相对较慢。
* 独立性：进程是独立的，一个进程出现问题不会影响其他进程的执行。线程则不同，一个线程的错误可能导致整个进程的崩溃。
* 系统支持：现代操作系统都支持多线程编程，而多进程编程在一些情况下可能不受支持或效率低下。
* 通信和同步：进程间通信（IPC）和同步较为复杂，需要使用专门的机制。线程间通信（inter-thread communication）和同步则较为简单，因为它们共享内存空间。

总的来说，进程和线程在资源占用、执行方式、开销、并发性、独立性、系统支持和通信同步等方面存在显著差异。选择使用哪种方式取决于具体的应用场景和需求。

</details>

##### 如何确保N个线程可以访问N个资源同时又不导致死锁？
<details>
    <summary>
        解题思路
    </summary>
 
* 围绕死锁的形成条件：多线程`交替乱序`同时获取`多把锁`，并且获取锁的方式是`死等`。 
* 例：线程1 先获取锁A，再获取锁B，线程2 先获取锁B，在获取锁A
</details>
<details>
    <summary>
        百度百科
    </summary>

* 资源编号与按顺序访问：对所有资源进行唯一编号，并且线程总是按照升序请求资源。如果线程已持有 ID 为 2 的资源，然后又请求 ID 为 1 的资源，则该线程会被阻塞，直到它释放 ID 为 2 的资源。这种策略可以消除循环等待条件，从而避免死锁。
  * 简单说就是不要同时获取多把锁。顺序访问共享资源
* 超时与重试：为资源请求设置超时时间。如果线程在预定时间内无法获得所需资源，它会释放其已经持有的所有资源，然后等待一段随机时间后重试。这种方式可以打破死锁的四个必要条件之一，从而避免死锁。
* 使用锁层次结构：锁层次结构是一种设计约定，它要求线程按照特定的顺序获取锁，从而避免循环等待。这种方式需要开发者对锁的使用有深入的理解和良好的纪律，但在大型系统中可能难以实现。
  * 按照固定的顺序获取多把锁
* 使用锁管理器：使用一种中央化的锁管理器，如分布式锁服务，这种服务可以在全局范围内对锁的获取进行排序和协调，以避免死锁。
* 减少锁的粒度：通过降低锁的粒度，可以减少线程之间的竞争。比如，使用细粒度的锁，只有需要访问一小部分数据的线程才会被阻塞，其他线程则可以继续执行。
* 使用尝试锁（TryLock）：Java 的 java.util.concurrent.locks 包提供了尝试锁（TryLock）的机制。线程可以使用 tryLock() 方法尝试获取锁，如果成功则立即返回 true，否则立即返回 false。这样，线程可以选择等待或者执行其他任务，从而降低死锁的可能性。
</details>

##### object 的 wait-notify 和 condition接口的区别

<details>
    <summary>
        解题思路
    </summary>
    <br>
    可以从使用上和原理上进行说明
</details>
<details>
    <summary>
        百度百科 + 自研
    </summary>
    
* wait()方法和Condition接口都是用于线程间的同步和协调的工具。
* wait()方法是Object类的成员，搭配synchronized使用
* 而Condition接口提供了一种更细粒度的控制，可以用于实现更复杂的同步需求，搭配lock一起使用
* 受阻塞的线程状态都是waiting，wait是on monitor object，condition 是parking
* notify和signal行为不同
  * notify : 立即恢复等待的线程，然后线程尝试获取锁，所以线程又马上进入锁等待状态 BLOCKED (on object monitor)
  * signal : condition和lock都是在AQS内部实现，parking线程可直接从condition的waiter队列head弹出，追加到lock的waiter队列中
    * 此过程线程未被唤醒，直到lock排队轮到该线程获后，该线程被唤醒同时获取到锁。
    * 这一点上使得signal 优于notify，避免了至少两次无用的线程状态切换。
</details>

##### 怎么理解什么是Java多线程同步?

<details>
    <summary>
        解题思路
    </summary>
    <br>
    同步可以理解为并发控制。就场景和方案说明。
</details>
<details>
    <summary>
        百度百科
    </summary>

* Java多线程同步指的是在多个线程同时访问共享资源时，为了保证数据的一致性和正确性，必须对资源的访问进行协调。这种协调可以通过互斥锁和共享锁来实现。
* 互斥锁可以通过synchronized关键字实现以及lock接口，它能够保证同一时刻只有一个线程能够访问被synchronized保护的资源，从而实现资源的互斥访问。当一个线程获得互斥锁并进入同步代码块时，其他线程将被阻塞，直到该线程释放互斥锁。
* 共享锁可以通过ReentrantReadWriteLock实现。它允许多个线程同时访问共享资源，但在写入数据时只允许一个线程进行。这种锁适用于读操作远多于写操作的场景，可以提高并发性能。
</details>

##### 简述如何调用 wait（）方法的？使用 if 块还是循环？为什么？

<details>
    <summary>
        解题思路
    </summary>

1. 虚假唤醒概念
2. ABA问题
3. 这个问题，其实不用想synchronized的底层问题，其实就是线程唤醒操作不具备原子性，就会引发ABA问题。其实无论wait-notify还是condition接口，都会出现。而解决ABA问题的办法就是循环CAS。
</details>
<details>
    <summary>
        百度百科
    </summary>

* 在Java中，wait()方法被用于使当前线程等待，直到其他线程调用该对象的notify()或notifyAll()方法。调用wait()方法时，需要将其放在synchronized块或方法中，因为wait()方法会释放对象锁，允许其他线程进入synchronized块。
* 通常，为了避免不必要的错误和混淆，我们使用循环来调用wait()方法，而不是简单的if块。原因主要有以下几点：
  * 避免虚假唤醒：在多线程环境中，线程的唤醒不一定因为我们期待的notify()或notifyAll()被调用，也可能是因为其他原因（比如“虚假唤醒”）。因此，使用循环来调用wait()方法并检查预期条件是否满足，可以确保线程在继续执行前满足正确的条件。
  * 确保正确性：使用循环可以让我们更好地控制线程唤醒后的行为。如果只用if块，一旦线程被唤醒，就会立即继续执行。但如果唤醒的时候条件并没有满足我们的预期，那么就可能导致程序出错。
</details>

##### 解释什么是多线程环境下的伪共享（false sharing）？

<details>
    <summary>
        解题思路
    </summary>

* `volatile 关键字`
* 连续的volatile变量不要出现同一段缓冲区中。
</details>
<details>
    <summary>
        百度百科
    </summary>
    <br>
多线程环境下的伪共享（false sharing）是指由于缓存一致性协议的影响，不同线程访问同一缓存行中的不同数据造成的性能下降现象。在多处理器系统中，每个处理器都有自己的局部缓存，当多个线程在不同的处理器上运行时，它们可能会对相同的缓存行进行操作。如果这些线程对变量的修改依赖于相同的缓存行，即使它们操作的是不同的数据，也会出现伪共享问题。
</details>

##### 解释为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？

<details>
    <summary>
        解题思路
    </summary>

      从wait-notify的语义上，wait会释放锁，notify交还锁
      可以从condition的实现进行分析，wait-notify模式的实现，
      1、需要两个保证线程安全的队列，一个存储等待线程，一个存储就绪线程
      2、需要一个锁，保证线程的同步。
      而监视器正好符合这两个要求，所以选择监视器实现wait-notify。而监视器搭配synchronized正好合适。
</details>
<details>
    <summary>
        百度百科
    </summary><br>

* 1、wait的语义：线程释放锁。释放锁必须先获取到锁
* 2、java锁的实现，依赖JVM内置的Monitor监视器。对象被关联到监视器对象上。默认情况下，对象的监视器为空，只有在对象首次被加锁时才初始化。
* 3、wait的实现是让当前线程进入到监视器的等待(阻塞)队列中，为了保证新增的原子性，需要依赖锁。印证：进入wait的线程状态为waiting(on monitor object)
* 4、而notify的实现是把等待队列的线程移动到就绪(排队)队列中。为了保证移动的原子性，所以需要加锁。 印证：被notify的线程状态为blocked(on monitor object)
* 5、monitor关联的两个队列本身属于共享数据，对于共享数据的修改，为了保证线程安全，前置锁刚好解决这个问题。
</details>

##### Java 如何实现多线程之间的通讯和协作？

<details>
    <summary>
        解题思路
    </summary>

        这个问题可以作为整个多线程的导火索。

</details>
<details>
    <summary>
        百度百科
    </summary><br>

1. 等待通知模型
   * 使用 wait() 和 notify() 方法: wait() 和 notify() 方法可用于实现线程间的通信。这些方法必须在 synchronized 块或方法中调用。当一个线程调用对象的 wait() 方法时，它释放对象的锁，让其他线程可以获取该锁并访问该对象。当其他线程调用 notify() 或 notifyAll() 方法时，正在等待的线程将被唤醒。
   * 使用JUC下的Condition接口 
2. 锁机制
   * 使用 synchronized 关键字: synchronized 关键字可以用于方法或代码块，以实现线程间的同步。当一个线程进入 synchronized 代码块时，其他试图进入此代码块的线程将被阻塞，直到第一个线程退出该代码块。这种方式可以用于实现线程间的同步和协作。
   * JUC下的Lock
3. JUC下的工具类
   * CountDownLatch 是一个同步辅助工具，它允许一个或多个线程等待，直到在其他线程执行的一组操作完成。
   * CyclicBarrier 是一个同步辅助工具，它允许一组线程互相等待，直到所有线程都达到某个公共屏障点（Barrier point）。
4. 使用Future接口
   * 构建线程时传入FutureTask而不是Runnable
   * 使用任务编排如：CompletableFuture 和 forkJoin等
5. 使用同步队列: Java 的 java.util.concurrent 包提供了 BlockingQueue 接口，它是一个线程安全的队列，可用于线程间的通信。一个线程可以将任务添加到队列中，而另一个线程可以从队列中取出任务。这种方式可以很方便地实现生产者-消费者模式。
6. thread.join 因为它要等另一个线程结束才会执行，而我们为了节省资源常常会选择复用线程，所以这个方法也基本没有用武之地了。
</details>

##### 详细阐述volatile为什么它能保证变量对所有线程的可见性？

<details>
    <summary>
        解题思路
    </summary>

      volatile的原理以及特性：可见性 、 顺序性 以及 不保证原子性
</details>
<details>
    <summary>
        百度百科
    </summary><br>

volatile是Java语言中的一个关键字，它能够确保多线程环境下变量的可见性和顺序性。具体来说，volatile关键字能保证如下两个特性：

* `可见性`：当一个线程修改了一个volatile变量的值，新值对其他线程来说能够立即知道。
* `顺序性`：volatile能够保证指令的执行顺序不被重排。
下面我们详细解释一下这两个特性：
### 可见性
* 在Java中，每个线程都有自己的工作内存，线程之间共享主存。当线程读取变量时，它首先在工作内存中查找该变量的值，如果工作内存中没有该变量的值，那么会从主存中读取。同样地，当线程修改一个变量的值时，它首先会更新工作内存中的值，然后再决定是否把工作内存中的值刷新到主存。
* 在多线程环境下，如果一个线程想要读取另一个线程修改的变量值，那么它必须通过工作内存来读取。然而，如果两个线程都在工作内存中找不到该变量的值，那么它们都会从主存中读取该变量的值。此时，就可能出现一个线程读取到另一个线程已经修改但尚未刷新到主存的变量值的情况，这就是所谓的“脏读”。
* volatile关键字能够禁止这种“脏读”。当一个线程修改了一个volatile变量的值后，它会立即把该变量的值刷新到主存。其他线程在读取该变量时，会直接从主存中读取到最新的值，从而确保了可见性。
### 顺序性
* 在多线程环境下，由于CPU的乱序执行和缓存一致性的问题，指令的执行顺序可能会发生重排。这可能会导致一个线程在另一个线程之前就完成了操作，从而产生不可预知的结果。
* volatile关键字能够防止这种情况发生。当一个线程修改了一个volatile变量后，它会立即把该变量的值刷新到主存。这个操作是一个“store-store”操作，它会强制CPU把该操作之前的所有指令都执行完毕。这样就能够保证指令的执行顺序不被重排，从而保证多线程环境下的正确性。

需要注意的是，虽然volatile能够保证可见性和顺序性，但它并不能保证原子性。也就是说，volatile无法保证复合操作（例如自增或自减等）在多线程环境下的安全性。如果需要保证原子性，那么需要使用其他的同步机制，例如synchronized关键字或者java.util.concurrent.atomic包中的原子类。
</details>

##### java的线程池是如何实现的？

<details>
    <summary>
        解题思路
    </summary>

       类似问题：
       1. 构造函数的参数个数
       2. 线程池中线程的创建和销毁过程
       3. 任务调度的过程
       线程池就那么点东西，主要看怎么组织语言
</details>
<details>
    <summary>
        百度百科
    </summary><br>

Java中的线程池是通过java.util.concurrent包中的ExecutorService接口实现的。ExecutorService接口是Java中线程池的核心，它提供了一组方法来管理线程，包括创建、启动、关闭线程等。

线程池的实现通常包括以下几个步骤：

1. 定义线程池的参数：线程池的大小（核心线程数）、最大线程数、存活时间等。
2. 创建线程池：通过Executors类或直接实现ExecutorService接口来创建线程池。
3. 提交任务：通过execute()或submit()方法将任务提交给线程池。
4. 线程池调度：线程池根据任务的数量和当前线程池的状态来调度任务。如果当前线程数小于核心线程数，则创建一个新的线程执行任务；如果当前线程数已经达到核心线程数，但仍有任务等待执行，则将任务放入等待队列中；如果当前线程数已经超过核心线程数，且等待队列已满，则根据任务优先级和等待时间等因素决定是否创建新的线程。
5. 线程池关闭：通过shutdown()或shutdownNow()方法关闭线程池。关闭后，线程池不再接受新的任务，但会继续执行已提交的任务。
6. 监控线程池：通过ThreadPoolExecutor类提供的监控方法来获取线程池的状态信息，如已提交的任务数、已完成的任务数、核心线程数等。

总的来说，Java中的线程池通过控制线程的数量和状态来优化系统资源的使用，提高程序的性能和响应速度。
</details>

##### 为什么要慎用threadlocal，使用threadlocal要注意什么

<details>
    <summary>
        解题思路
    </summary>

        threadlocal原理

</details>
<details>
    <summary>
        百度百科
    </summary><br>

ThreadLocal被设计用于处理线程局部变量，它能够为每个线程提供独立的变量副本，从而避免多个线程之间共享变量可能引发的问题。然而，过度使用ThreadLocal可能导致内存泄漏问题。这是因为在Java中，每个线程都有自己的堆栈，当线程不再需要时，其堆栈上的所有对象都应该被垃圾回收。然而，ThreadLocal对象是弱引用的，这意味着当线程结束时，ThreadLocal对象可能不会被垃圾回收。这可能会导致内存泄漏问题。

在使用ThreadLocal时，需要注意以下几点：

* 初始化：ThreadLocal应该在静态代码块中进行初始化，以确保每个线程都拥有自己的实例。
* 值的管理：ThreadLocal实例应该被视为不可变的，不应该在多个线程之间共享。每个线程应该只使用自己的实例。
* 内存泄漏问题：如果ThreadLocal实例被存储在Thread对象中，并且线程结束时没有清除这些实例，可能会导致内存泄漏。因此，在使用ThreadLocal时，应该注意在适当的时候清除实例。
* 线程安全问题：虽然ThreadLocal本身是线程安全的，但是在使用ThreadLocal时需要注意避免条件竞争和死锁等问题。
</details>

##### 什么是线程安全

<details>
    <summary>
        解题思路
    </summary>

        

</details>
<details>
    <summary>
        百度百科
    </summary><br>

多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。
</details>

##### Thread.interrupt原理

<details>
    <summary>
        解析
    </summary>

        

</details>
<details>
    <summary>
        示例：
    </summary><br>

1. Thread.interrupt 和 Thread.isInterrupted是一对方法
2. Thread.interrupt 并不会直接中断线程，该方法内部分为两步：
    * 将JVM的osThread线程状态变更为1，即中断状态
    * 将支持中断的挂起状态线程唤醒，比如：Object.wait、LockSupport.park、Thread.sleep等
</details>
