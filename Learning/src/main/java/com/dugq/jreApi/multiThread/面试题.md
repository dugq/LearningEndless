
<details>
    <summary>
        如何确保N个线程可以访问N个资源同时又不导致死锁？
    </summary>

* 资源编号与按顺序访问：对所有资源进行唯一编号，并且线程总是按照升序请求资源。如果线程已持有 ID 为 2 的资源，然后又请求 ID 为 1 的资源，则该线程会被阻塞，直到它释放 ID 为 2 的资源。这种策略可以消除循环等待条件，从而避免死锁。
* 超时与重试：为资源请求设置超时时间。如果线程在预定时间内无法获得所需资源，它会释放其已经持有的所有资源，然后等待一段随机时间后重试。这种方式可以打破死锁的四个必要条件之一，从而避免死锁。
* 使用锁层次结构：锁层次结构是一种设计约定，它要求线程按照特定的顺序获取锁，从而避免循环等待。这种方式需要开发者对锁的使用有深入的理解和良好的纪律，但在大型系统中可能难以实现。
* 使用锁管理器：使用一种中央化的锁管理器，如分布式锁服务，这种服务可以在全局范围内对锁的获取进行排序和协调，以避免死锁。
* 减少锁的粒度：通过降低锁的粒度，可以减少线程之间的竞争。比如，使用细粒度的锁，只有需要访问一小部分数据的线程才会被阻塞，其他线程则可以继续执行。
* 使用尝试锁（TryLock）：Java 的 java.util.concurrent.locks 包提供了尝试锁（TryLock）的机制。线程可以使用 tryLock() 方法尝试获取锁，如果成功则立即返回 true，否则立即返回 false。这样，线程可以选择等待或者执行其他任务，从而降低死锁的可能性。
</details>
