@[toc]

# LockSupport
* LockSupport#park 阻塞当前线程。
  * blocker参数是一个字符串，用于描述阻塞线程的原因。这个参数通常被用于调试和诊断，帮助开发人员识别出是哪个线程在调用park方法时被阻塞了。在调用park方法时，可以传入一个blocker参数，以便在以后的调试过程中能够快速定位到被阻塞的线程和阻塞的原因。
* LockSupport#unpark 唤醒线程，参数为需要解锁的线程。
  * 注意：唤醒是可以发生在阻塞前的。先唤醒，则后续的第一次阻塞，不会生效。
### 原理
* 依赖的是操作系统的park方法，使线程进入waiting状态
* [测试类](LockSupportParkTest.java)

# Object wait-notify
* [LockSupportParkTest # testWaitAndNotify](LockSupportParkTest.java)
* 需要搭配synchronized一起使用。wait的对象需要先获取到锁。
* 在调用wait方法后，会释放锁，被notify时，线程被恢复，然后尝试获取取锁。
* 在wait后，notify/notifyAll之前，线程处于 WAITING (on object monitor) 状态
* 当调用notifyAll后，未获取到锁的线程状态变更为：BLOCKED (on object monitor)

# condition 
* [LockSupportParkTest # testConditionWaitAndNotify](LockSupportParkTest.java)
* 需要搭配Lock一起使用。await的对象需要先获取到锁。
* 在调用await方法后，会释放锁，被signalAll时，需要先获取到锁。
* 在wait后，signal/signalAll之前，线程处于 WAITING (parking)状态
* 当调用notifyAll后，未获取到锁的线程状态变更为：WAITING (parking)

# condition vs wait-notify
* 使用方法不同，wait-notify 需要搭配synchronized使用，而wait-notify需要搭配lock使用
* wait vs await：
  * 相同点：都会在wait后释放锁，在被唤醒后要先获取锁。 
  * wait : wait是native方法，类似pthread函数，使得线程进入WAITING (on object monitor)状态
  * await :利用的是lockSupport.park方法，，使得线程进入WAITING (parking)状态
* notify vs signal :
  * notify : 立即恢复等待的线程，然后线程尝试获取锁，所以线程又马上进入锁等待状态 BLOCKED (on object monitor)
  * signal : condition和lock都是在AQS内部实现，parking线程可直接从condition的waiter队列head弹出，追加到lock的waiter队列中
    * 此过程线程未被唤醒，直到lock排队轮到该线程获后，该线程被唤醒同时获取到锁。
    * 这一点上使得signal 优于notify，避免了至少两次无用的线程状态切换。

# [ThreadLocal](util%2FThreadLocal.md)
