##### 一条 SQL 语句在数据库框架中的执行流程

<details>
    <summary>
        解题思路
    </summary>

        根据mysql架构逐一分析： 连接器、查询缓存、分析器、优化器、执行器
        也可补充一些善后工作

</details>
<details>
    <summary>
        百度百科
    </summary><br>

1. 缓存检查。mysql8.0之前，查询SQL会先经过查询缓存，如果缓存命中，则直接返回数据
2. 分析SQL，生成执行计划。这部分包含词法分析和语义分析。如分析结果指示SQL存在错误，直接返回。
3. 优化SQL。 mysql优化器会对SQL执行计划进行优化。包含：索引、join等
4. 执行SQL。根据SQL执行计划开始执行SQL。这部分依赖存储引擎提供的API实现。也包含mysql一些特性实现。比如binlog，以及存储引擎方面的工作，比如redolog 和 undolog
5. 返回结果。将SQL执行的结果返回给客户端。
6. 必要的清理工作。比如性能监控，慢SQL等，还有本次操作的资源损耗回收等
</details>

##### 数据库的三范式是什么

<details>
    <summary>
        解题思路
    </summary>

        第一范式：强调列的原子性
        第二范式：强调联合主键的原子性
        第三范式：强调非主键的简洁、不冗余
</details>
<details>
    <summary>
        百度百科
    </summary><br>

1. 每一列都是不可分割的。
2. 联合主键情况，字段都应与主键有关联。如成绩表，主键学生id，学科id，不应该出现学生班级信息之类的字段。
3. 表不包含多余属性，学生属性属于学生，班级属性属于班级。
 
</details>

##### char 和 varchar 的区别？

<details>
    <summary>
        解题思路
    </summary>

[存储和检索方式不同](https://dev.mysql.com/doc/refman/8.0/en/char.html) 


</details>
<details>
    <summary>
        百度百科
    </summary><br>

1. 可存储字节不同。char 最大存储255字符，而varchar最大为65535
2. 存储格式不同。
   * char 存储的字节数为固定值，不管内容的大小，如内容不够，则使用0填充。
   * varchar 存储上是可变长度，前一个或两个字节存储字节长度，后面跟着实际数据。
   * InnoDB将长度大于或等于 768 字节的固定长度字段编码为可变长度字段，可以存储在页外。例如， CHAR(255)如果字符集的最大字节长度大于 3，则列可以超过 768 个字节，就像utf8mb4.
3. 根据属性配置不同，char读取的结果不同。尾部填充的空格可读取出来，变为空格。而varchar没这烦恼。

</details>

##### mysql 不走索引的原因

<details>
    <summary>
        解题思路
    </summary>

        mysql执行器没办法根据索引搜索的情况

</details>
<details>
    <summary>
        百度百科
    </summary><br>

1. 索引列参与运算
   * 正则表达式
   * 函数运算
   * 表达式计算
2. 模糊匹配
3. 类型不匹配
4. or关联的条件存在不走索引的情况
5. 优化器觉得不走索引优于索引
</details>

##### 谈谈你对MVCC 的了解？

<details>
    <summary>
        解题思路
    </summary>

        2W1H

</details>
<details>
    <summary>
        百度百科
    </summary><br>

数据库并发场景：
* 读-读：不存在任何问题，也不需要并发控制；
* 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；
* 写-写：有线程安全问题，可能会存在更新丢失问题。

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。

MVCC 可以为数据库解决以下问题：
1. 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；
2. 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。
</details>


##### 既然mysql二级索引页会导致写如压力，那它的写入也可能造成页分裂等问题，那主键有序的意义是啥呢？

<details>
    <summary>
        解题思路
    </summary>

        2W1H

</details>
<details>
    <summary>
        百度百科
    </summary><br>

###### 这是一个非常好的问题！在 MySQL 中，即使二级索引可能导致页分裂和写入压力，主键有序仍然具有重要的意义，主要体现在以下几个方面：

1. 主键的有序性和聚簇索引的优势
*  聚簇索引（Clustered Index）：
   *  在 InnoDB 存储引擎中，表的数据实际上是存储在主键的 B+ 树结构中的，这个结构被称为聚簇索引。
   * 由于聚簇索引将数据和主键索引存储在一起，主键的有序性意味着插入的数据会按顺序排列在磁盘上。这种顺序排列减少了磁盘上的随机写入，有助于减少页分裂和提高磁盘I/O性能。
* 写入效率：
  * 当主键是有序的（如自增ID），新的记录总是追加到表的末尾，不需要在已有的索引树中查找插入点。这种顺序写入减少了B+树的重平衡操作，降低了页分裂的风险。
  * 顺序插入使得磁盘写入操作更加线性，减少了磁盘寻道的开销，提升了写入性能。
2. 主键有序性对二级索引的影响
  * 二级索引的指针优化：
    * 在 InnoDB 中，二级索引的叶子节点存储的是主键的值作为指针指向对应的记录。如果主键是有序的，那么二级索引的主键指针同样具有一定的顺序性，这种顺序性可以提高二级索引的检索性能。
    * 虽然二级索引的插入可能导致页分裂，但主键有序性能够在一定程度上减少二级索引的随机性，因为主键是依赖于有序的插入的。
  * 减少写放大效应：
    * 如果主键是有序的，并且二级索引不是特别多或者特别复杂，写入过程中由于聚簇索引顺序性带来的优势会明显高于由于二级索引的页分裂带来的负面影响。
    * 总的来说，主键的有序性能够减少数据库整体的写放大效应（即每次写入所带来的额外写入开销）。
3. 主键有序性与数据分区
  * 分区表的优势：
    * 主键有序在分区表中表现得尤为明显。通过合理的分区策略（如按主键范围分区），数据的写入可以被高效地分配到不同的分区，从而平衡写入负载。
    * 这不仅提高了写入性能，还能提升并发处理能力，特别是在需要同时处理大量写入的情况下。
4. 查询性能的优化
 * 顺序扫描效率：
   * 有序主键使得顺序扫描更高效。例如，对于常见的范围查询（如通过主键查询一个范围的数据），数据库引擎可以快速地定位数据的开始和结束位置，从而显著提高查询性能。
   * 对于需要排序的查询，如果主键本身有序，可以避免额外的排序开销。
 ###### 总结
   主键有序性 在 MySQL 中的主要意义在于优化 聚簇索引 的结构，使得数据存储和写入操作更为高效。尽管二级索引可能引发页分裂和写入压力，但主键的有序性能够显著减少这些问题对整体系统性能的影响。具体而言：
* 顺序写入减少了B+树的重平衡操作和页分裂，提高了写入性能。
* 有序的主键使得二级索引的维护更为高效，即使二级索引不是完全有序。
* 在查询和范围扫描中，有序主键的优势尤为明显，提供了更好的查询性能。

因此，尽管二级索引可能引入一些复杂性，主键有序仍然是设计数据库表时的一个重要考量因素。


</details>









