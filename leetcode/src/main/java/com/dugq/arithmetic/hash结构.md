# hash结构
## 结构
* hash的结构实现一般都是：数组+链表

        [ entry1,     entry2,  entry3]
           ｜          ｜       ｜
         entry11      entry22    entry33

* 元素一般会定一个对象数据结构
  
       class entry {
         Object key;
         object value;
         entry next;
      }

* hash快速查找：数组结构
  * 元素被封装为entry后，放在数组里，key的hash值相对应的下标位置上
  * 数组的长度一般采用2的n次幂。
    * hash是int类型，可能比数组长度大，所以会hash % len来保证数组不越界。而取模操作比较耗费性能
    * 当数组的长度位2的n次幂时，由于数组下表从0开始，所以计算下标 = hash % (2<sup>n</sup> -1) = hash &  (2<sup>n</sup> -1)
    * 利用 与运算 代替 取模运算，效率大大提高

* hash冲突： 链表结构
  * 当hash值冲突时，数组的某个位上是不能存放多个元素，所以采用链表存储在上一个hash相同位的后面
  * 链表优化
    * 在链表中通过key查询数据，只能通过遍历的方式。当链表太大时，查询的效率就会底下
    * 可以在链表长度达到一定程度时，采用树结构代替链表
    * java中hashMap的树化
      * 树是有序结构。java中再次以hash进行树化
      * jdk认为hash冲突大概率是hash % n 冲突，而hash本身并没多大冲突
      * 也就是说，对于一个对象hash的获取至关重要
  * redis中并没有进行hash冲突优化。这要看它对hash的计算了

* 负载因子： 元素个数/数组长度
  * 理想情况下，hash结构希望的是数组的每位上存储都是一个entry。此时负载因子是：1
  * 负载因子一定程度上反映了hash冲突的概率。所以负载因子应该小于1


* 扩容：
  * 当负载因子过大时，数组必须扩容，以满足hash的散列

* 收缩
  * 当负载因子过小时，数组应该收收缩，以减少内存占用



