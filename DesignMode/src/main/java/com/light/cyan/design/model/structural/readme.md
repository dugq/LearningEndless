## 结构型模式
##### 介绍
* 结构型模式关注类和对象的组合，通过继承或组合，建立新的功能结构
* 结构型模式有一些相似之处，它们都涉及如何组织和组合类或对象，但每种模式的侧重点和应用场景不同，设计目标也不一样。
* 为了更好理解这些模式的区别，可以从目的、实现方式和应用场景等角度来看它们的不同。

#### 适配器模式
###### 目的
* 解决接口不兼容的问题。适配器将一个类的接口转换为另一个接口，使得不兼容的接口能够协同工作。
* 不兼容接口的类之间的解耦。
###### 实现方式
* 通过创建一个适配器类，封装被适配的对象，并在适配器中提供新的接口实现，从而调用被适配对象的功能。
###### 应用场景
* 需要复用一些现有类，但这些类的接口不符合现有系统要求时。
* 不改变旧代码的场景下 修改出入参数，适配器模式可以作为一种解耦方式。
###### 关键点
* 适配不同接口，重点是解决接口不兼容问题。
###### 结构
* 目标接口 ：客户需要的接口。
* 适配者类 ：已经存在的接口，这个接口需要适配。
* 适配器类 ： 实现目标接口，并持有被适配者类的实例。
###### 示例
~~~java
// 将数组转化为List 
// 它内部包含了一个数组，然后实现AbstractList抽象类，实现其方法，让数组拥有了数组的能力。
// 目标接口： AbstractList 
// 适配者类： 数组 
// 适配器类： Arrays$ArrayList
 List<String> list = Arrays.asList("A", "B", "C");
// 将inputStream转化为Reader
// 目标接口： Reader 
// 适配者类： FileInputStream
// 适配器类：InputStreamReader
 Reader reader = new InputStreamReader(new FileInputStream("input.txt"), "UTF-8");

~~~ 

#### 桥接模式
###### 目的
* 抽象化与实现化解耦
* 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。
* 目的是将抽象与实现分离，使它们可以独立地变化，该模式通过将一个对象的抽象部分与它的实现部分分离，使它们可以独立地改变。它通过组合的方式，而不是继承的方式，将抽象和实现的部分连接起来。
###### 实现方式
* 使用“组合”而不是“继承”来连接抽象部分和实现部分，使得两个部分可以独立演化。
* 通过将类的抽象部分和其实现部分分开（通常是通过接口和实现类）。
* 将不同角度的分类逻辑分离，允许它们独立变化。
###### 应用场景
* 当需要把抽象和实现分离时
* 当需要对一个系统进行多维度的扩展时，如操作系统和设备之间的适配。
###### 关键点
* 抽象与实现的分离，解决的是多个维度独立变化的问题
* 当我们面向接口编程时，入参不同（特指实现类型，不是查询条件）结果不同，代码不需要变更。
* 从大的角度想，jdk本身就是一个桥接模式的实现。它为开发者屏蔽了操作系统之间的差异，使得Java应用拥有可以跨平台能力。
###### 结构
* 抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。
* 扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。
* 实现（Implementor）：定义实现接口，提供基本操作的接口。
* 具体实现（Concrete Implementor）：实现实现接口的具体类。
###### 示例
[WrapperModelTest.java](WrapperModelTest.java)
~~~java
// jdk定义了connection的抽象，以及connection提供出的能力，如prepareStatement、CallableStatement等
// 各家厂商提供实现类，如mysql的实现类，oracle的实现类等，实现了connection的具体能力。
// jvm启动时会从所有的jar包中加载数据库驱动，然后通过DriverManager.registerDriver注册到jvm中
Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "user", "password");// 执行SQL操作，与具体数据库的实现解耦
Statement statement = connection.createStatement();
ResultSet rs = statement.executeQuery("SELECT * FROM users");
~~~

####  组合模式
###### 目的
* 单个对象与对象组合结构之间的解耦。
* 把一组相似的对象当作一个单一的对象
* 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
* 将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
###### 实现方式
* 定义筛选接口：创建一个筛选接口，定义一个筛选方法。
* 实现具体筛选器：为每个筛选标准实现筛选接口，封装具体的筛选逻辑。
* 组合筛选器：允许筛选器之间进行组合，形成复杂的筛选逻辑。
###### 应用场景
* 当需要表示对象的层次结构时，如文件系统或组织结构。
* 当希望客户端代码能够以一致的方式处理树形结构中的所有对象时。
###### 关键点
* 创建了对象组的树形结构

#### 装饰器模式
###### 目的
* 对象功能的动态扩展与原始对象代码之间的解耦。
* 动态地给一个对象添加额外的职责，同时不改变其结构。装饰器模式提供了一种灵活的替代继承方式来扩展功能。
* 避免通过继承引入静态特征，特别是在子类数量急剧膨胀的情况下。
* 允许在运行时动态地添加或修改对象的功能。
###### 实现方式
* 定义组件接口：创建一个接口，规定可以动态添加职责的对象的标准。
* 创建具体组件：实现该接口的具体类，提供基本功能。
* 创建抽象装饰者：实现同样的接口，持有一个组件接口的引用，可以在任何时候动态地添加功能。
* 创建具体装饰者：扩展抽象装饰者，添加额外的职责。
###### 应用场景
* 当需要在不增加大量子类的情况下扩展类的功能。
* 当需要动态地添加或撤销对象的功能。
###### 关键点
* 动态扩展与原始对象
###### 结构
* 抽象组件（Component）：定义了原始对象和装饰器对象的公共接口或抽象类，可以是具体组件类的父类或接口。
* 具体组件（Concrete Component）：是被装饰的原始对象，它定义了需要添加新功能的对象。
* 抽象装饰器（Decorator）：继承自抽象组件，它包含了一个抽象组件对象，并定义了与抽象组件相同的接口，同时可以通过组合方式持有其他装饰器对象。
* 具体装饰器（Concrete Decorator）：实现了抽象装饰器的接口，负责向抽象组件添加新的功能。具体装饰器通常会在调用原始对象的方法之前或之后执行自己的操作。
###### 示例
[WrapperModelTest.java](WrapperModelTest.java)
~~~java
InputStream inputStream = new FileInputStream("file.txt");
// 
InputStream bufferedStream = new BufferedInputStream(inputStream);
InputStream dataStream = new DataInputStream(bufferedStream);
~~~

#### 装饰器模式
###### 实现方式
* 定义组件接口：创建一个接口，规定可以动态添加职责的对象的标准。
* 创建具体组件：实现该接口的具体类，提供基本功能。
* 创建抽象装饰者：实现同样的接口，持有一个组件接口的引用，可以在任何时候动态地添加功能。
* 创建具体装饰者：扩展抽象装饰者，添加额外的职责。
###### 应用场景
* 当需要在不增加大量子类的情况下扩展类的功能。
* 当需要动态地添加或撤销对象的功能。
###### 关键点
* 动态扩展与原始对象
###### 结构
* 抽象组件（Component）：定义了原始对象和装饰器对象的公共接口或抽象类，可以是具体组件类的父类或接口。
* 具体组件（Concrete Component）：是被装饰的原始对象，它定义了需要添加新功能的对象。
* 抽象装饰器（Decorator）：继承自抽象组件，它包含了一个抽象组件对象，并定义了与抽象组件相同的接口，同时可以通过组合方式持有其他装饰器对象。
* 具体装饰器（Concrete Decorator）：实现了抽象装饰器的接口，负责向抽象组件添加新的功能。具体装饰器通常会在调用原始对象的方法之前或之后执行自己的操作。
###### 示例
[WrapperModelTest.java](WrapperModelTest.java)
~~~java
InputStream inputStream = new FileInputStream("file.txt");
// 
InputStream bufferedStream = new BufferedInputStream(inputStream);
InputStream dataStream = new DataInputStream(bufferedStream);
~~~

#### 外观模式
###### 目的
* 复杂子系统与客户端之间的耦合。
* 为子系统提供一个统一的接口，简化客户端对子系统的访问。
###### 示例
* springDataRedis，redisTemplate提供相同的接口，不管底层是jedis还是lettuce亦或者redisson，客户端只需要调用redisTemplate的接口即可。

##### 

#### 相似的设计模式

| 模式 | 适配器模式   | 装饰器模式 | 外观模式          | 代理模式  |
|:---|:--------|:------|:--------------|:------|
| 区别 | 转换对象的接口 | 扩展原对象 | 简化，屏蔽子系统的复杂关系 | 管理子系统 |
* 相同点，他们都是持有某个子对象，向外提供的能力都是依赖子对象的能力。体现一个封装的思想。

* 桥接模式： 把实现和抽象解耦。 它重在抽象的定义。
   * 比如： redis客户端的设计，不同的数据结构有自己的能力，client向外提供各自的Operation。每个Operation独立。
* 享元模式： 重在对象共享。 它重在对象池的概念。
* 组合模式： 重在树形结构的管理。 它重在树形结构的管理。
